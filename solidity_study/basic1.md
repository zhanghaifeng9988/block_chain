# solidity 语言学习记录

# 第一个智能合约代码--代币制造
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.26;
//下面的合约实现了一个最简单的加密货币
//币确实可以无中生有地产生，但是只有创建合约的人才能做到（实现一个不同的发行计划也不难）。
//任何人都可以给其他人转币，不需要注册用户名和密码 —— 所需要的只是以太坊密钥对。

contract Coin {
    // address 类型的公共变量,关键字“public”让这些变量可以从外部读取
    // address 类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对。
    address public minter;
    //mapping 引用类型 是一种键值对存储结构,作用是高效地通过键（Key）查找对应的值（Value）
    //用于存储每个地址的余额
    mapping (address => uint) public balances;

    // 轻客户端可以通过事件针对变化作出高效的反应
    event Sent(address from, address to, uint amount);

    // 这是构造函数，只有当合约创建时运行
    constructor()  {
        //msg.sender表示当前合约的创建者的地址。在构造函数中，minter 存储创建合约的人的地址。
        minter = msg.sender;
    }
// 如果 mint 被合约创建者外的其他人调用，则什么也不会发生
// 如果调用mint函数的是合约的创建者，那么就可以用来管理用户的余额，就是铸造代币的数量
    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;//将铸造的金额（amount）加到接收者的余额（balances[receiver]）上
    }

// send 函数可被任何人用于向他人发送币 (当然，前提是发送者拥有符合数量的币)。
    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}

## mapping
mapping 是一种键值对存储结构，类似于其他编程语言中的“字典”或“哈希表”，但它并不是函数，而是语言内置的引用类型。它的核心作用是高效地通过键（Key）查找对应的值（Value）。

###  mapping 的基本语法
mapping(KeyType => ValueType) public variableName;

KeyType：键的类型，通常是 address、uint、bytes32 等简单类型（不能是复杂类型如 struct 或其他 mapping）。
ValueType：值的类型，可以是任意类型（包括 uint、string、struct 甚至嵌套 mapping）。


## event
event Sent(address from, address to, uint amount);

这行代码定义了一个名为 Sent 的事件。它包含三个参数：
address from：表示发送方的地址。
address to：表示接收方的地址。
uint amount：表示发送的金额。
**作用**
所有的事件都包含了 from ， to 和 amount 三个参数，可方便追踪事务。
当你在智能合约中触发这个事件时，它会将这些**参数记录到区块链的交易日志中**。外部应用程序可以通过监听这些事件来获取合约执行过程中的相关信息。

## 合约中的构造函数
 constructor()  {
//msg.sender表示当前合约的创建者的地址。在构造函数中，minter 存储创建合约的人的地址。
        minter = msg.sender;
    }

msg (以及 tx 和 block ) 是一个神奇的全局变量，其中包含一些允许访问区块链的属性。 msg.sender 始终是当前（外部）函数调用的来源地址。


## 合约中的方法1
铸造代币


## 合约中的方法2
转账

## emit
在智能合约的函数中，你可以使用 emit 关键字来触发event 定义的事件。

## 合约包含的代码类型内容：
- 定义构造函数：用于创建合约对象，它永久存储创建合约的人的地址；
- 定义一般类型属性（状态变量）：合约的状态变量；例如：address，uint，bool等；
- 定义mapping类型的属性（状态变量）：存储在区块链上的键值对类型数据结构；
- 定义event类型的事件：合约执行过程中触发的事件；
- 定义方法：比如铸造代币，转账等。


## 合约部署
在以太坊智能合约中，使用Solidity语言编写的合约代码在部署到区块链上时，会自动触发合约的构造函数（constructor）来完成初始化。


## 监听智能合约中定义的事件 --web3.js

web3.js 是一套用来与区块链进行交互的JavaScript API。
使用 web3.js 可以监听智能合约中定义的事件，并实时获取事件参数。

Coin.Sent().watch({}, '', function(error, result) {
    if (!error) {
        console.log("Coin transfer: " + result.args.amount +
            " coins were sent from " + result.args.from +
            " to " + result.args.to + ".");
        console.log("Balances now:\n" +
            "Sender: " + Coin.balances.call(result.args.from) +
            "Receiver: " + Coin.balances.call(result.args.to));
    }
})


# 区块链的一些补充知识

##  交易/事务
区块链是全球共享的事务性数据库，这意味着每个人都可加入网络来阅读数据库中的记录。
如果你想改变数据库中的某些东西，你必须创建一个被所有其他人所接受的事务。
事务一词意味着你想做的（假设您想要同时更改两个值），要么一点没做，要么全部完成。
此外，当你的事务被应用到数据库时，其他事务不能修改数据库。
- **交易总是由发送人（创建者）签名**。

##  区块 
在比特币中，要解决的一个主要难题，被称为**双花攻击 (double-spend attack)**：如果网络存在两笔交易，**都想****花光****同一个账户**的钱时（即所谓的冲突）会发生什么情况？交易互相冲突？

- 网络会为你自动选择一条交易序列，并打包到所谓的“区块”中，然后它们将在所有参与节点中执行和分发。
- 如果两笔交易互相矛盾，那么最终被确认为,后发生的交易将被拒绝，不会被包含到区块中。
- 作为“顺序选择机制”（也就是所谓的“挖矿”）的一部分，**可能有时会发生块（blocks）被回滚**的情况，但仅在链的“末端”。


# 以太坊虚拟机
## 概述
1. 以太坊虚拟机 EVM 是智能合约的运行环境。
2. 它不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行代码是无法访问网络、文件系统和其他进程的。
3. EVM 的隔离性是为了保护区块链的安全和稳定，而外部交互则通过特定的机制（如 Oracle 服务，Web3 应用等）来实现。这样既能保证智能合约的安全性，又能使其具备与外部世界交互的能力。

## 账户
以太坊中有两类账户（它们共用同一个地址空间）：无论帐户是否存储代码，这两类账户对 EVM 来说是一样的。

1. **外部账户：** 由公钥-私钥对（也就是人）控制；也就是web3钱包中创建的公链账户信息；**无代码**，能够主动发起交易；外部账户的地址是由公钥决定的
2. **合约账户：** 由智能合约控制，**由代码**创建和控制。合约账户的地址是在创建该合约时确定的；
由和账户一起存储的智能合约代码控制，正常不能主动发起交易，如果发起主动交易，需被 EOA 或其他合约触发。
3. 每个**账户**都有一个**键值对形式的持久化存储**。其中 **key 和 value 的长度都是256位**，我们称之为 **存储** 。
4. 每个账户有一个以太币余额（ balance ）（单位是“Wei”）。


## 交易
1. 交易可以看作是从一个帐户发送到另一个帐户的消息，消息能包含**一个二进制数据（合约负载）**和**以太币**。
2. 如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。
3. 如果目标账户是零账户(账户地址为 0)，此交易将创建一个 新合约 :如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。
这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。
**注意：**在合约创建的过程中，它的代码还是空的。所以直到构造函数执行结束，你都不应该在其中调用合约自己函数。


## Gas
1. 每笔交易都收取一定数量的 gas ，目的是限制执行交易所需要的工作量和为交易支付手续费。
2. EVM 执行交易时，gas 将按特定规则逐渐耗尽。
gas price 是交易发送者设置的一个值，发送者账户需要预付的手续费= gas_price * gas
3. 无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前调用帧（call frame）所做的所有状态修改都将被**回滚**。
4. 调用帧（call frame），指的是下文讲到的EVM的运行栈（stack）中当前操作所需要的若干元素。



## 存储，内存和栈
1. 每个账户有一块持久化内存区称为 **存储** 。 
存储是将256位字映射到256位字的键值存储区；
**在合约中枚举存储是不可能的；**且读存储的相对开销很高，修改存储的开销甚至更高
2. 合约只能读写存储区内属于自己的部分。
3. 第二个内存区称为 **内存** ，合约会试图为**每一次消息调用**获取一块被重新擦拭干净的内存实例。
4.  EVM 不是基于寄存器的，而是基于栈的，因此所有的计算都在一个被称为 **栈**（stack） 的区域执行。
栈最大有1024个元素，每个元素长度是一个字（256位）。


## 消息调用
1. 合约可以通过消息调用的方式来调用其它合约或者发送以太币到非合约账户。
2. 消息调用和交易非常类似，它们都有一个源、目标、数据、以太币、gas和返回数据。
3. 事实上每个交易都由一个顶层消息调用组成，这个消息调用又可创建更多的消息调用。
4. Solidity中，发起调用的合约默认会触发一个手工的异常，以便异常可以从调用栈里“冒泡出来”；
5. 调用深度被限制为 1024 ，因此对于更加复杂的操作，我们应使用循环而不是递归。



## 委托调用/代码调用
### 有一种特殊类型的消息调用，被称为 委托调用(delegatecall) 。
它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 msg.sender 和 msg.value 不变。 
委托调用的目的是允许一个合约调用另一个合约的函数，而不用担心它们的执行环境。
这意味着一个合约可以在运行时从另外一个地址动态加载代码。
存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。
### 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。


## 日志
有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。
这个特性被称为 日志(logs) ，Solidity用它来实现 事件(events) 。
因为部分日志数据被存储在 布隆过滤器（Bloom filter) 中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。


##  创建
合约甚至可以通过一个特殊的指令来创建其他合约（不是简单的调用零地址）。创建合约的调用 create calls 和普通消息调用的唯一区别在于，负载会被执行，执行的结果被存储为合约代码，调用者/创建者在栈上得到新合约的地址。


## 自毁
合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 selfdestruct。
合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。


